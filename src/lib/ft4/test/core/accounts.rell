@test module;

import ^^^.auth;
import ^^^.admin;
import ^^^.core.accounts;
import ^^^.accounts.strategies;
import ^^^.accounts.strategies.open;
import test_auth: ^.auth;

/**
 * Creates a single signature auth descriptor from the provided information and returns it.
 * This function does not make any database calls.
 * 
 * @param signer        publc key part of the keypair which will be used to sign this auth descriptor
 * @param permissions   list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.TRANSFER]`
 * @param rules         gtv encoded list of rules that this auth descriptor will have. Defaults to `null`
 */
function create_auth_descriptor(
    signer: byte_array,
    permissions: list<text> = [accounts.auth_flags.TRANSFER],
    rules: gtv = null.to_gtv()
) = accounts.auth_descriptor(
        accounts.auth_type.S,
        [
            set(permissions).to_gtv(),
            signer.to_gtv()
        ],
        rules
    );

/**
 * Creates a multi-signature auth descriptor from the provided information and returns it.
 * This function does not make any database calls.
 * 
 * @param signatures_required   how many signatures from the signers list need to sign an operation in order for it to be valid
 *                              when authorizing with this auth descriptor.
 * 
 * @param signers               publc key part of the keypairs which will be allowed to sign this auth descriptor
 * @param permissions           list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.TRANSFER]`
 * @param rules                 gtv encoded list of rules that this auth descriptor will have. Defaults to `null`
 */
function create_multisig_auth_descriptor(
    signatures_required: integer,
    signers: list<byte_array>,
    permissions: list<text> = [accounts.auth_flags.TRANSFER],
    rules: gtv = null.to_gtv()
) = accounts.auth_descriptor(
        accounts.auth_type.M,
        [
            set(permissions).to_gtv(),
            signatures_required.to_gtv(),
            signers.to_gtv()
        ],
        rules
    );

/**
 * Creates a transaction that can be run to create an account using ft signatures. I.e.,
 * this function does not actually run the transaction, only creates one
 * that can be run later. Example usage:
 * 
 * ```
 *  test.create_register_account_tx(
 *      open.ras_open(auth_descriptor),
 *      register_account_opstrategies.external.register_account()
 *  )
 *  .sign(keypair)
 *  .run();
 * ```
 * 
 * @param strategy_op           the strategy which will be used to create this account
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function create_register_account_tx(
    strategy_op: rell.test.op,
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    require(
        strategies.is_strategy_op(strategy_op.to_gtx_operation()),
        "Expected account registration strategy operation, found <%s>".format(strategy_op.name)
    );

    return rell.test.tx([strategy_op, register_account_op]);
}

/**
 * Creates a transaction that can be run to create an account using evm signatures. I.e.,
 * this function does not actually run the transaction, only creates one
 * that can be run later. Example usage:
 * 
 * ```
 *  test.create_register_account_evm_tx(
 *      open.ras_open(auth_descriptor),
 *      register_account_opstrategies.external.register_account()
 *  )
 *  .run();
 * ```
 * 
 * @param keypairs              a list of keypairs that will sign the transaction
 * @param strategy_op           the strategy which will be used to create this account
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function create_register_account_evm_tx(
    keypairs: list<rell.test.keypair>,
    strategy_op: rell.test.op,
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    require(
        strategies.is_strategy_op(strategy_op.to_gtx_operation()),
        "Expected account registration strategy operation, found <%s>".format(strategy_op.name)
    );

    val message = strategies.get_register_account_message(
        strategy_op.to_gtx_operation(), 
        register_account_op.to_gtx_operation()
    );
    
    val evm_addresses = list<byte_array>();
    val signatures = list<auth.signature?>();
    for (keypair in keypairs) {
        evm_addresses.add(crypto.eth_privkey_to_address(keypair.priv));
        signatures.add(test_auth.evm_sign(message, keypair.priv));
    }

    return rell.test.tx([
        auth.external.evm_signatures(evm_addresses, signatures),
        strategy_op,
        register_account_op
    ]);
}

/**
 * Registers an account (using ft signatures) with the specified keypair as
 * signer using the provided strategy and the provided register account operation.
 * This function then returns the data needed to interact with the newly created account.
 * 
 * @param keypair               the keypair that will be the signer of this account
 * @param strategy_op           the strategy which will be used to create this account
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_account(
    rell.test.keypair,
    strategy_op: rell.test.op,
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    create_register_account_tx(strategy_op, register_account_op)
        .sign(keypair)
        .run();

    val account_id = strategies.get_account_id_for_strategy(strategy_op.to_gtx_operation());
    val account = accounts.account @ { .id == account_id };
    val auth_descriptor_id = accounts.main_auth_descriptor @ { 
        .account.id == account_id 
    } .auth_descriptor.id;

    return ft_account_data(
        account = account,
        auth_descriptor_id = auth_descriptor_id,
        ft_auth = test_auth.ft_auth(account.id, auth_descriptor_id, *),
        keypair = keypair
    );
}

/**
 * Registers an account (using evm signatures) with the specified keypair as
 * signer using the provided strategy and the provided register account operation.
 * This function then returns the data needed to interact with the newly created account.
 * 
 * @param keypair               the keypair that will be the signer of this account
 * @param strategy_op           the strategy which will be used to create this account
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_account_evm(
    rell.test.keypair,
    strategy_op: rell.test.op,
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    create_register_account_evm_tx([keypair], strategy_op, register_account_op)
        .sign(keypair)
        .run();

    val account_id = strategies.get_account_id_for_strategy(strategy_op.to_gtx_operation());
    val account = accounts.account @ { .id == account_id };
    val auth_descriptor_id = accounts.main_auth_descriptor @ { 
        .account.id == account_id 
    } .auth_descriptor.id;

    return evm_account_data(
        account = account,
        auth_descriptor_id = auth_descriptor_id,
        evm_auth = test_auth.evm_auth(keypair, account.id, auth_descriptor_id, *),
        keypair = keypair
    );    
}

/**
 * Register a new account using the provided single sig auth descriptor.
 * 
 * @see register_account_with_multisig_auth_descriptor for account registration with a multisig auth descriptor
 * 
 * @param auth_descriptor   the main auth desctiptor of the new account, must be single sig
 * @param user_keypair      the keypair that corresponds to the signer within the auth descriptor
 */
function register_account_with_auth_descriptor(
    accounts.auth_descriptor,
    user_keypair: rell.test.keypair
) {
    return register_account_with_multisig_auth_descriptor(auth_descriptor, [user_keypair]);
}

/**
 * Register a new account using the provided multi sig auth descriptor.
 * 
 * @see register_account_with_auth_descriptor for account registration with a single auth descriptor
 * 
 * @param auth_descriptor   the main auth desctiptor of the new account, must be multi sig
 * @param keys              list of keypairs that corresponds to the signers within the auth descriptor
 */
function register_account_with_multisig_auth_descriptor(
    accounts.auth_descriptor,
    keys: list<rell.test.keypair>
) {
    val op = admin.external.register_account(auth_descriptor);
    val admin_keypair = rell.test.keypair(
            priv=test_auth.admin_priv_key(),
            pub=crypto.privkey_to_pubkey(test_auth.admin_priv_key(), true)
        );
    keys.add(admin_keypair);
    var tx = _sign_many(op, keys);
    tx.run();

    val auth_descriptor_id = auth_descriptor.hash();
    val account = accounts.account_auth_descriptor @ {
        .id == auth_descriptor_id
    } .account;

    return ft_account_data(
        account,
        auth_descriptor_id,
        ft_auth = test_auth.ft_auth(account.id, auth_descriptor_id, *),
        keypair = keys[0] // Doesn't matter much which we use
    );
}

function _sign_many(op: rell.test.op, keys: list<rell.test.keypair>) {
    val tx = rell.test.tx(op);
    keys @* { } ( tx.sign($) );
    return tx;
}

/**
 * A struct representing information neccessary to interact with an account using ft keys.
 */
struct ft_account_data {
    /**
     * A function that will accept an operation and perform the neccessary steps to
     * make it authorizable with ft auth on the account with the auth descriptor that
     * is stored within this struct.
     */
    ft_auth: (rell.test.op) -> list<rell.test.op>;
    /**
     * The account which the rest of the fields in this struct is associated with.
     */
    accounts.account;
    /**
     * The id of an auth descriptor that is associated with the account stored in this
     * struct and which can be signed using the stored keypair. This is also the id
     * of the auth descriptor that will be used when calling the auth functions in
     * this struct.
     */
    auth_descriptor_id: byte_array;
    /**
     * The keypair that corresponds to the signer field stored in in auth descriptor
     * pointed out by the `auth_descriptor_id` field.
     */
    rell.test.keypair;
}

/**
 * A struct representing information neccessary to interact with an account using evm keys.
 */
struct evm_account_data {
    /**
     * A function that will accept an operation and perform the neccessary steps to
     * make it authorizable with evm auth on the account with the auth descriptor that
     * is stored within this struct.
     */
    evm_auth: (rell.test.op) -> list<rell.test.op>;
    /**
     * The account which the rest of the fields in this struct is associated with.
     */
    accounts.account;
    /**
     * The id of an auth descriptor that is associated with the account stored in this
     * struct and which can be signed using the stored keypair. This is also the id
     * of the auth descriptor that will be used when calling the auth functions in
     * this struct.
     */
    auth_descriptor_id: byte_array;
    /**
     * The keypair that corresponds to the signer field stored in in auth descriptor
     * pointed out by the `auth_descriptor_id` field.
     */
    rell.test.keypair;
}

/**
 * Registers an account using the open strategy and ft signatures. The account will be created
 * with a single sig auth descriptor with the provided keypair as signer, and
 * with the provided flags array as permissions.
 * 
 * @param keypair               the keypair that will have access to the account
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_account_open(
    rell.test.keypair,
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account(
        keypair,
        open.ras_open(
            accounts.single_sig_auth_descriptor(keypair.pub, set(flags))
        ),
        register_account_op
    );
}

/**
 * Registers an account using the keypair `rell.test.keypairs.alice` using ft signing.
 * 
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_alice(
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account_open(rell.test.keypairs.alice, flags, register_account_op);
}

/**
 * Registers an account using the keypair `rell.test.keypairs.bob` using ft signing.
 * 
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_bob(
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account_open(rell.test.keypairs.bob, flags, register_account_op);
}

/**
 * Registers an account using the keypair `rell.test.keypairs.eve` using ft signing.
 * 
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_eve(
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account_open(rell.test.keypairs.eve, flags, register_account_op);
}

/**
 * Registers an account using the keypair `rell.test.keypairs.trudy` using ft signing.
 * 
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_trudy(
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account_open(rell.test.keypairs.trudy, flags, register_account_op);
}

/**
 * Registers an account using the open strategy and evm signatures. The account will be created
 * with a single sig auth descriptor with the provided keypair as signer, and
 * with the provided flags array as permissions.
 * 
 * @param keypair               the keypair that will have access to the account
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_account_open_evm(
    rell.test.keypair,
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    val address = crypto.eth_pubkey_to_address(keypair.pub);

    return register_account_evm(
        keypair,
        open.ras_open(
            accounts.single_sig_auth_descriptor(address, set(flags))
        ),
        register_account_op
    );
}

/**
 * Registers an account using the keypair `rell.test.keypairs.alice` using evm signing.
 * 
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_alice_evm(
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account_open_evm(rell.test.keypairs.alice, flags, register_account_op);
}

/**
 * Registers an account using the keypair `rell.test.keypairs.bob` using evm signing.
 * 
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_bob_evm(
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account_open_evm(rell.test.keypairs.bob, flags, register_account_op);
}

/**
 * Registers an account using the keypair `rell.test.keypairs.eve` using evm signing.
 * 
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_eve_evm(
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account_open_evm(rell.test.keypairs.eve, flags, register_account_op);
}

/**
 * Registers an account using the keypair `rell.test.keypairs.trudy` using evm signing.
 * 
 * @param flags                 list of strings, representing permissions that this auth descriptor will get. Defaults to `[accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER]`
 * @param register_account_op   the operation that will be used to create the account, defaults to `strategies.external.register_account()`
 */
function register_trudy_evm(
    flags: list<text> = [accounts.auth_flags.ACCOUNT, accounts.auth_flags.TRANSFER],
    register_account_op: rell.test.op = strategies.external.register_account()
) {
    return register_account_open_evm(rell.test.keypairs.trudy, flags, register_account_op);
}

