@mount('gtx_api')
module;

/**
 * Return value of `priority_check_v1` query.
 * It is used to represent how to prioritize a transaction: if multiple transactions
 * are in queue, the one with the highest priority value will be executed first.
 */
struct priority_state_v1 {
    /**
     * ID of account which wants to push the transaction forward.
     * A transaction can be multi-party, it's up to the dapp to decide who's the
     * "main actor" of the transaction.
     */
    account_id: byte_array?;

    /**
     * Number of points currently associated with the account.
     * If this is lower than `tx_cost_point`, the transaction will be rejected.
     */
    account_points: integer;

    /**
     * Number of points which this transaction costs.
     * If this is higher than `account_points`, the transaction will be rejected.
     * 
     * If many transactions from this account are in queue, the costs are summed up to see if
     * the account would be able to complete them all.
     */
    tx_cost_points: integer;

    /** priority, higher is better */
    priority: decimal;
}

/**
 * This query is used by Postchain.
 * It will be called for every transaction, and the result will be used to determine the 
 * transaction priority.
 * 
 * This is not an actual implementation, it simply calls `priority_check` to allow the
 * implementation of this query to be defined by the end user.
 * 
 * Throws if the implementation defined in `priority_check` throws.
 * 
 * @see https://gitlab.com/chromaway/postchain/blob/dev/postchain-base/src/main/kotlin/net/postchain/base/BaseTransactionPrioritizer.kt
 * 
 * @param tx_body             the transaction
 * @param tx_size             size of the transaction in bytes
 * @param tx_enter_timestamp  when the transaction entered the queue
 * @param current_timestamp   the current timestamp
 */
query priority_check_v1(tx_body: gtx_transaction_body, tx_size: integer, tx_enter_timestamp: timestamp, current_timestamp: timestamp): priority_state_v1 =
    priority_check(tx_body, tx_size, tx_enter_timestamp, current_timestamp) ?: no_op_priority_state();

/**
 * Extendable function that allows to define custom prioritization strategies.
 * If unimplemented, it will return `no_op_priority_state()`, which means everything will
 * have a priority of zero.
 * 
 * If this function throws, it will be interpreted as a value of `no_op_priority_state()`
 * as well
 * 
 * Throws if any extension of this function throws.
 * 
 * @param tx_body             the transaction
 * @param tx_size             size of the transaction in bytes
 * @param tx_enter_timestamp  when the transaction entered the queue
 * @param current_timestamp   the current timestamp
 */
@extendable function priority_check(tx_body: gtx_transaction_body, tx_size: integer, tx_enter_timestamp: timestamp, current_timestamp: timestamp): priority_state_v1?;

/**
 * An "empty" priority state, which represents the lowest priority, with no account information.
 * The default value returned as priority when `priority_check` is left with no extension,
 * or the extension does not return. 
 */
function no_op_priority_state() =
    priority_state_v1(
        account_id = null,
        account_points = 0,
        tx_cost_points = 0,
        priority = 0.0
    );

/**
 * An "empty" priority state, which does not point to an account, but has a priority value.
 * `no_account_priority_state(0.0)` is equivalent to `no_op_priority_state()`
 * 
 * @param priority  the priority value, must be greater than 0
 */
function no_account_priority_state(priority: decimal) =
    priority_state_v1(
        account_id = null,
        account_points = 0,
        tx_cost_points = 0,
        priority = priority
    );
