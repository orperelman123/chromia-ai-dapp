/**
 * When an `account` entity has this as its `type` field, it is a lock account
 * 
 * A lock account is like a safe where tokens are put when the users should not be able
 * to access them. This is useful, for example, when the users have staked those tokens
 * or they are participating in an auction where they have put a bid for a certain amount
 * of tokens.
 * 
 * In both cases, the users are still the owners of the assets, but they're not allowed to
 * use them.
 * 
 * An `account_link` entity is created that holds the relevant information:
 * 
 * - account: the account that owns the asset
 * - secondary: the lock account
 * - type: the purpose of the locking (e.g. "staking", or "auction")
 * 
 * @see accounts.linking.account_link for information on account linking
 */
val ACCOUNT_TYPE_LOCK = "FT4_LOCK";

/**
 * Retrieves the lock account given an account and the lock type.
 * Creates the account if it does not exist.
 *
 * Can only be called from an operation.
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 *
 * @param type      the type of lock account
 * @param account   the account with which the lock account is associated
 */
function ensure_lock_account(type: text, accounts.account): accounts.account {
    val link = linking.account_link @? { 
        .account == account,
        .secondary.type == ACCOUNT_TYPE_LOCK,
        .type == type 
    };

    if (link??) return link.secondary;

    val secondary = accounts.create_account_without_auth(
        get_lock_account_id(account, type), 
        ACCOUNT_TYPE_LOCK
    );
    
    create linking.account_link(
        account = account,
        secondary = secondary,
        type = type
    );

    return secondary;
}

/**
 * Gets all existing lock accounts for the provided account
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 *
 * @param account   the account with which the lock accounts are associated
 */
function get_lock_accounts(accounts.account) {
    return linking.account_link @* { 
        .account == account, 
        .secondary.type == ACCOUNT_TYPE_LOCK 
    } (
        type = .type,
        account = .secondary
    );
}

/**
 * Gets existing lock accounts for the provided account where some assets have been locked
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 * 
 * @param account   the account with which the lock accounts are associated
 */
function get_lock_accounts_with_non_zero_balances(accounts.account) {
    return linking.account_link @* {
        .account == account,
        .secondary.type == ACCOUNT_TYPE_LOCK,
        exists(assets.balance @* { .account == account_link.secondary })
    } (
        type = .type,
        account = .secondary
    );
}

/**
 * Computes the id that the lock account will have given the account and the type.
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 * 
 * @param account   the account that is going to be using this lock account
 * @param type      the type of the lock account for which to derive the id
 */
function get_lock_account_id(accounts.account, type: text) {
    return (account.id, ACCOUNT_TYPE_LOCK, type).hash();
}

/**
 * Transfers an asset to the lock account, rendering it inaccessible to the user.
 *
 * Can only be called from an operation.
 * 
 * Throws if the required assets cannot be moved. Common cases include:
 * - the amount to transfer is not in the accepted range (0, 2^256) (exclusive)
 * - some conditions added in development through transfer extensions (`before_transfer` or
 *   `after_transfer`) aren't met
 * - the account's balance is lower than `amount`
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 * 
 * @param type      the type of lock account to use to lock the asset
 * @param account   the account that has the asset to lock
 * @param asset     the asset to lock
 * @param amount    how much of the specified asset to lock
 */
function lock_asset(type: text, accounts.account, assets.asset, amount: big_integer) {
    val lock_account = ensure_lock_account(type, account);

    assets.Unsafe.transfer(account, lock_account, asset, amount);
}

/**
 * Retrieves an asset from the lock account back to the specified account.
 * Note that this function does not perform any authorization before moving the assets;
 * users should thus not be given direct access to this function.
 *
 * Can only be called from an operation.
 * 
 * Throws if the required assets cannot be moved. Common cases include:
 * - the amount to transfer is not in the accepted range (0, 2^256) (exclusive)
 * - some conditions added in development through transfer extensions (`before_transfer` or
 *   `after_transfer`) aren't met
 * - the lock account's balance is lower than `amount`, which means there's less locked tokens
 *   than what is being unlocked
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 * 
 * @param type      the type of lock account to which the asset were locked
 * @param account   account that locked the assets
 * @param asset     the asset to unlock
 * @param amount    how much of the specified asset to unlock
 */
function unlock_asset(type: text, accounts.account, assets.asset, amount: big_integer) {
    val lock_account = ensure_lock_account(type, account);

    assets.Unsafe.transfer(lock_account, account, asset, amount);
}

/**
 * Retrieves all balances of a certain asset that were locked from a certain account. Paginated,
 * the returned data is a list of tuples containing the amount and a lock type label:
 * `list<(lock type, amount)>`
 * 
 * @see utils.paged_result for information about pagination
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 * 
 * @see get_locked_asset_aggregated_balance for a function that reports the sum of all these
 * values
 * 
 * @see get_locked_asset_balances for a function that reports these values for all assets.
 *  
 * @param account       account that locked their assets
 * @param asset         the asset that was locked
 * @param types         optional list to specify what lock account types to include balances for.
 *                      If not specified, balances will be fetched for all lock account types.
 * @param page_size     the size of the pages to retrieve
 * @param page_cursor   a pointer to where the page should start
 * 
 * @return pagination result, where the data is a list of tuples: list<(text, amount)>
 */
function get_locked_asset_balance(
    accounts.account, 
    assets.asset, 
    types: list<text>? = null, 
    page_size: integer? = null, 
    page_cursor: text? = null
) {
    val before_rowid = utils.before_rowid(page_cursor);
    return (al: linking.account_link, b: assets.balance) @* {
        al.account == account,
        al.secondary.type == ACCOUNT_TYPE_LOCK,
        if (types??) al.type in types else true,
        b.account == al.secondary,
        b.asset == asset,
        b.rowid > (before_rowid ?: rowid(0))
    } (
        @omit @sort b,
        utils.pagination_result(
            data = (
                type = al.type,
                amount = b.amount
            ).to_gtv_pretty(),
            rowid = b.rowid
        )
    ) limit utils.fetch_data_size(page_size);
}

/**
 * Retrieves the total locked sum of the specified asset over various lock types, given the
 * account that locked them.
 * The returned value adds up the values that were locked, regardless of the lock type, for a
 * single asset.
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 * 
 * @see get_locked_asset_balance for a function that reports all values separated by lock type
 * 
 * @see get_locked_asset_aggregated_balances for a function that reports this value for all
 * assets.
 *  
 * @param account   the account that locked their assets
 * @param asset     the asset that was locked
 * @param types     optional list to specify what lock account types to include balances for.
 *                  If not specified, balances will be included for all lock account types.
 * 
 * @return the sum of the locked asset across the specified lock account types
 */
function get_locked_asset_aggregated_balance(
    accounts.account, 
    assets.asset, 
    types: list<text>? = null
) {
    return (al: linking.account_link, b: assets.balance) @? {
        al.account == account,
        al.secondary.type == ACCOUNT_TYPE_LOCK,
        if (types??) al.type in types else true,        
        b.account == al.secondary,
        b.asset == asset
    } (
        @omit @group b.asset,
        @sum b.amount
    ) ?: 0L;    
}

/**
 * Similar to `get_locked_asset_balance`, except that it allows retrieving the info for all
 * locked assets.
 * 
 * @see utils.paged_result for information about pagination
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 * 
 * @see get_locked_asset_balance for a function that reports all values for a single asset
 * 
 * @see get_locked_asset_aggregated_balances for a function that reports the sum of all these
 * values, separated by asset
 *  
 * @param account       from which the assets were locked
 * @param types         optional list to specify what lock account types to include balances for.
 *                      If not specified, balances will be fetched for all lock account types.
 * @param page_size     the size of the pages to retrieve
 * @param page_cursor   a pointer to where the page should start
 * 
 * @return pagination result, where the data is a list of tuples: list<(type, asset, amount)>
 */
function get_locked_asset_balances(
    accounts.account, 
    types: list<text>? = null, 
    page_size: integer? = null, 
    page_cursor: text? = null
) {
    val before_rowid = utils.before_rowid(page_cursor);
    val assets = (al: linking.account_link, b: assets.balance) @* {
        al.account == account,
        al.secondary.type == ACCOUNT_TYPE_LOCK,
        if (types??) al.type in types else true,        
        b.account == al.secondary,
        b.rowid > (before_rowid ?: rowid(0))
    } (
        @omit @sort b,
        utils.pagination_result(
            data = (
                type = al.type,
                asset = assets.map_asset(b.asset),
                amount = b.amount
            ).to_gtv_pretty(),
            rowid = b.rowid
        )

    ) limit utils.fetch_data_size(page_size);

    return assets;
}

/**
 * Similar to `get_locked_asset_aggregated_balance`, except that it allows retrieving the info
 * for all locked assets.
 * 
 * @see utils.paged_result for information about pagination
 * 
 * @see ACCOUNT_TYPE_LOCK for more information on lock accounts
 * 
 * @see get_locked_asset_balances for a function that reports all values separated by lock type
 * 
 * @see get_locked_asset_aggregated_balance for a function that reports the summed values for
 * a single asset
 *  
 * @param account       from which the assets were locked
 * @param types         optional list to specify what lock account types to include balances for.
 *                      If not specified, balances will be fetched for all lock account types.
 * @param page_size     the size of the pages to retrieve
 * @param page_cursor   a pointer to where the page should start
 * 
 * @return pagination result, where the data is a list of tuples: list<(asset, amount)>
 */
function get_locked_asset_aggregated_balances(
    accounts.account, 
    types: list<text>? = null, 
    page_size: integer? = null, 
    page_cursor: text? = null
) {
    val before_rowid = utils.before_rowid(page_cursor);
    val balances = (al: linking.account_link, b: assets.balance) @* {
        al.account == account,
        al.secondary.type == ACCOUNT_TYPE_LOCK,
        if (types??) al.type in types else true,        
        b.account == al.secondary,
        b.asset.rowid > (before_rowid ?: rowid(0))
    } (
        @sort @group asset = b.asset,
        @sum amount = b.amount
    ) limit utils.fetch_data_size(page_size);

    return balances @* {} (
        utils.pagination_result(
            data = (
                asset = assets.map_asset(.asset),
                amount = .amount
            ).to_gtv_pretty(),
            rowid = .asset.rowid
        )
    );
}
