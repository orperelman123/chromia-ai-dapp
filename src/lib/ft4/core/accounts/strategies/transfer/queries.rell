
/**
 * Retrieves a list of assets that are allowed for account creation on this chain, given the
 * parameters of the transfer that is going to register one.
 * 
 * @param sender_blockchain_rid     the RID of the blockchain assets will come from
 * @param sender_id                 the ID of the sender account
 * @param recipient_id              the ID of the account that will be registered
 * 
 * @return `null` if all assets are allowed or a list of tuples `(asset_id, min_amount)`
 * otherwise
 */
query get_allowed_assets(sender_blockchain_rid: byte_array, sender_id: byte_array, recipient_id: byte_array):
        list<(asset_id: byte_array, min_amount: big_integer)>? {
    val rule = find_allowed_assets(sender_blockchain_rid, sender_id, recipient_id);
    if (rule == null) return null;
    val allowed_assets = list<(asset_id: byte_array, min_amount: big_integer)>();
    for ((asset_id, min_amount) in rule) {
        allowed_assets.add((asset_id = asset_id, min_amount = min_amount));
    }
    return allowed_assets;
}

/**
 * Retrieves all `account_creation_transfer`s that are pending (that is, not recalled nor
 * completed), optionally filtering them based on whether they expired or not.
 * 
 * @param recipient_id  the ID found in `account_creation_transfer.recipient_id`
 * @param filter        an optional filter that returned transfers will match. If null, all
 *                      transfers will be returned.
 */
query get_pending_transfer_strategies(
    recipient_id: byte_array,
    filter: pending_transfer_filter? = null
): set<text> {
    val strats = account_creation_transfer @* {
        recipient_id,
        .state == account_creation_state.pending
    };

    var strategies_list = list<set<text>>();
    val strategies = set<text>();

    if (
        filter == null or              // no filter object
        filter.state == null or        // no filter for state
        filter.state!!.contains_all(   // filter allows both valid and expired
            pending_transfer_expiration_state.values()
        )
    ) {
        strategies_list = strats @* {} (map<text,rule>.from_gtv(gtv.from_bytes(.rules)).keys());
    }
    else {
        strategies_list = strats @* {
            filter_account_creation_transfer($, filter.state!!)
        } (map<text,rule>.from_gtv(gtv.from_bytes(.rules)).keys());
    }

    for (s in strategies_list) {
        strategies.add_all(s);
    }
    return strategies;
}

/**
 * Returns whether a certain **pending** `account_creation_transfer` exists, which means that
 * a certain sender has sent the specified amount of this asset and the recipient has not yet
 * created that account.
 * 
 * @param strategy_name             the name of the strategy that is to be found
 * @param sender_blockchain_rid     the RID of the blockchain where the transfer originated.
 *                                  Can be this blockchain's RID for on-chain transfers.
 * @param sender_id                 the ID of the sender account
 * @param recipient_id              the ID of the account that is going to be registered
 * @param asset_id                  the ID of the asset that was sent
 * @param amount                    the amount of the above asset that was transferred
 */
query has_pending_create_account_transfer_for_strategy(
    strategy_name: text,  
    sender_blockchain_rid: byte_array,
    sender_id: byte_array,
    recipient_id: byte_array,
    asset_id: byte_array,
    amount: big_integer
) {
    val transfers = account_creation_transfer @* {
        .recipient_id == recipient_id,
        .sender_blockchain_rid == sender_blockchain_rid,
        .sender_id == sender_id,
        .asset.id == asset_id,
        .amount == amount,
        .state == account_creation_state.pending
    };

    for (transfer in transfers) {
        val rules = map<text, rule>.from_gtv(gtv.from_bytes(transfer.rules));
        
        if (not (strategy_name in rules)) continue;
        val rule = rules[strategy_name];

        if (
            is_blockchain_allowed(rule, sender_blockchain_rid) and
            is_sender_allowed(rule, sender_id) and
            is_recipient_allowed(rule, recipient_id, sender_id) and
            is_asset_amount_allowed(rule, transfer.asset, amount)
        ) {
            return true;
        }
    }

    return false;
}

/**
 * Returns a list of `rule`s representing all conditions under which assets can be transferred
 * to register a new account. For a transaction to be allowed, it must fulfill all criteria
 * for at least one of the rules. 
 * 
 * Throws if any rule found in the `chromia.yml` is misconfigured. Common cases of
 * misconfiguration can be found on the API docs for `get_config`
 * 
 * @see get_config for information on common rule misconfigurations.
 */
query get_transfer_rules() {
    val rules = get_config();

    // asset issuing BRID -> map(asset name -> asset)
    val assets_cache = map<byte_array, map<name, assets.asset>>();

    val mapped_rules = list<rule>();

    for (rule in rules) {
        val _assets = list<asset_limit>();
        
        for (asset in rule.asset_limits) {
            if (asset.id != null) continue;

            val name = asset.name!!;
            val brid = asset.issuing_blockchain_rid!!;

            var _asset = assets_cache.get_or_null(brid)?.get_or_null(name);
            if (empty(_asset)) {
                _asset = assets.asset @? { .name == name, .issuing_blockchain_rid == brid };
                if (empty(_asset)) {
                    continue;
                }
                if (not assets_cache.contains(brid)) {
                    assets_cache[brid] = map<name, assets.asset>();
                }
                assets_cache[brid][name] = _asset!!;
            }

            _assets.add(
                asset_limit(
                    id = _asset.id,
                    name = _asset.name,
                    issuing_blockchain_rid = _asset.issuing_blockchain_rid,
                    min_amount = asset.min_amount
                )
            );
        }

        mapped_rules.add(rule(
            strategies = rule.strategies,
            timeout_days = rule.timeout_days,
            blockchains = rule.blockchains,
            senders = rule.senders,
            recipients = rule.recipients,
            require_same_address = rule.require_same_address,
            allow_all_assets = rule.allow_all_assets,
            asset_limits = _assets
        ));
    }

    return mapped_rules;
} 
