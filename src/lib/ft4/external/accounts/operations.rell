
function delete_auth_descriptor_message(gtv) {
    val params = struct<delete_auth_descriptor>.from_gtv(gtv);
    return "Please sign the message\nto delete auth descriptor:\n%s\n\nfrom account\n{account_id}".format(params.auth_descriptor_id);
}

function delete_auth_descriptor_resolver(args: gtv, account_id: byte_array, auth_descriptor_ids: list<byte_array>) {
    val params = struct<delete_auth_descriptor>.from_gtv(args);
    if (params.auth_descriptor_id in auth_descriptor_ids) return params.auth_descriptor_id;

    for (ad in accounts.account_auth_descriptor @* { .account.id == account_id, .id in auth_descriptor_ids }) {
        if (accounts.has_flags(ad, [accounts.auth_flags.ACCOUNT])) return ad.id;
    }

    return null;
}

@extend(auth.auth_handler)
function () = auth.add_overridable_auth_handler(
    scope = rell.meta(delete_auth_descriptor).mount_name,
    flags = [],
    message = delete_auth_descriptor_message(*),
    resolver = delete_auth_descriptor_resolver(*)
);

/**
 * Deletes the auth descriptor with the specified id.
 * 
 * Must be signed by an auth descriptor with `accounts.auth_flags.ACCOUNT`. 
 * 
 * If the auth descriptor to delete is the same that is authorizing the operation,
 * the account flag restriction is removed.
 * 
 * *Note:* Deleting an auth descriptor using this operation will delete the auth 
 * descriptor from every account it is associated with.
 * 
 * If the provided auth descriptor happens to be the main auth descriptor of any account,
 * this operation will fail.
 * 
 * @param auth_descriptor_id    the id of the auth descriptor to delete
 */
operation delete_auth_descriptor(auth_descriptor_id: byte_array) {
    val (account, auth_desc_after, deleted_descriptors)  = auth.authenticate_and_return_context();
    val descriptor_is_deleted = deleted_descriptors @? {auth_descriptor_id==.id}(.id) != null;
    if(descriptor_is_deleted) return;
    accounts.delete_auth_descriptor(
        accounts.auth_descriptor_by_id(account, auth_descriptor_id)
    );
}

function delete_auth_descriptors_for_signer_message(gtv) {
    val params = struct<delete_auth_descriptors_for_signer>.from_gtv(gtv);
    return "Please sign the message\nto delete all auth descriptor for signer:\n%s\n\nfrom account\n{account_id}".format(params.signer);
}

function delete_auth_descriptors_for_signer_resolver(args: gtv, account_id: byte_array, auth_descriptor_ids: list<byte_array>) {
    val params = struct<delete_auth_descriptors_for_signer>.from_gtv(args);

    val ads = (a_ad: accounts.account_auth_descriptor, ad_s: accounts.auth_descriptor_signer) @* {
        a_ad.account.id == account_id,
        ad_s.account_auth_descriptor == a_ad,
        ad_s.id == params.signer,
        a_ad.auth_type == accounts.auth_type.S,
        a_ad.id in auth_descriptor_ids
    } (a_ad.id);
    if (not ads.empty()) {
        return ads[0];
    }

    for (ad in accounts.account_auth_descriptor @* { .account.id == account_id, .id in auth_descriptor_ids }) {
        if (accounts.has_flags(ad, [accounts.auth_flags.ACCOUNT])) return ad.id;
    }

    return null;
}

@extend(auth.auth_handler)
function () = auth.add_overridable_auth_handler(
    scope = rell.meta(delete_auth_descriptors_for_signer).mount_name,
    flags = [],
    message = delete_auth_descriptors_for_signer_message(*),
    resolver = delete_auth_descriptors_for_signer_resolver(*)
);

/**
 * Deletes all auth descriptors from an account for which the provided signer is included in
 * the signers array.
 * 
 * Must be signed by an auth descriptor with `accounts.auth_flags.ACCOUNT`.
 * 
 * *Note:* Deleting an auth descriptor using this operation will delete the auth 
 * descriptor from every account it is associated with.
 * 
 * If any of the matched auth descriptors happens to be the main auth descriptor of any account,
 * this operation will fail.
 * 
 *  Throws `"UNSUPPORTED SIGNER"` if the signer's size does not match either:
 *  - `EVM_ADDRESS_SIZE` length of 20 bytes
 *  - `FT_PUBKEY_SIZE` length of 33 bytes
 * 
 * @param signer    the signer for which to delete auth descriptors
 */
operation delete_auth_descriptors_for_signer(signer: byte_array) {
    val account = auth.authenticate();

    auth.validate_signer(signer);

    val ads = (a_ad: accounts.account_auth_descriptor, ad_s: accounts.auth_descriptor_signer) @* {
        a_ad.account == account,
        ad_s.account_auth_descriptor == a_ad,
        ad_s.id == signer
    } (a_ad);
    for (ad in ads) {
        accounts.delete_auth_descriptor(ad);
    }
}

function delete_all_auth_descriptors_except_main_message(gtv) {
    return "Please sign the message\nto delete all auth descriptors except main\nfrom account:\n{account_id}";
}

function delete_all_auth_descriptors_except_main_resolver(args: gtv, account_id: byte_array, auth_descriptor_ids: list<byte_array>) {
    val main_auth_descriptor = require(
        accounts.main_auth_descriptor @? { .account.id == account_id } .auth_descriptor,
        "Account <%s> does not have main auth descriptor set".format(account_id)
    );

    return if (main_auth_descriptor.id in auth_descriptor_ids) main_auth_descriptor.id else null;
}

@extend(auth.auth_handler)
function () = auth.add_overridable_auth_handler(
    scope = rell.meta(delete_all_auth_descriptors_except_main).mount_name,
    flags = [accounts.auth_flags.ACCOUNT],
    message = delete_all_auth_descriptors_except_main_message(*),
    resolver = delete_all_auth_descriptors_except_main_resolver(*)
);

/**
 * This operation does what it says on the label, it removes all the auth descriptors
 * that is associated with an account except for the main one. 
 * 
 * This function can be called only by the main auth descriptor, which is also supposed to
 * have the `accounts.auth_flags.ACCOUNT`.
 * 
 * *Note:* Deleting auth descriptors using this operation will delete the auth 
 * descriptors from every account they are associated with.
 */
operation delete_all_auth_descriptors_except_main() {
    val account = auth.authenticate();
    accounts.delete_all_auth_descriptors_except_main(account);
}

function add_auth_descriptor_message(gtv) {
    val params = struct<add_auth_descriptor>.from_gtv(gtv);
    val flags = params.new_desc.args[0];

    return "Please sign the message\nto add auth descriptor\nwith flags:\n%s\n\nto account:\n{account_id}".format(flags);
}

@extend(auth.auth_handler)
function () = auth.add_overridable_auth_handler(
    scope = rell.meta(add_auth_descriptor).mount_name,
    flags = [accounts.auth_flags.ACCOUNT],
    message = add_auth_descriptor_message(*)
);

/**
 * Adds a new auth descriptor to an account. The account in question will be 
 * the account which is referred to by the preceding auth operation.
 * 
 * Must be signed by an auth descriptor with `accounts.auth_flags.ACCOUNT`
 * that is already associated with the account, as well as the signer of the new auth
 * descriptor.
 * In case the new auth descriptor is a multi sig auth descriptor, every signer
 * that is part of the auth descriptor must sign this operation, even if the number of
 * required signatures is less than the number of signers.
 * 
 * @param new_desc  the auth descriptor to add to the account
 */
operation add_auth_descriptor(new_desc: accounts.auth_descriptor) {
    val account = auth.authenticate();
    val signers = accounts.get_signers(new_desc);
    auth.verify_signers(signers);
    accounts.add_auth_descriptor(account, new_desc);
}

function update_main_auth_descriptor_message(gtv) {
    val params = struct<update_main_auth_descriptor>.from_gtv(gtv);
    val flags = params.new_desc.args[0];
    val signers = accounts.get_signers(params.new_desc);

    return "Please sign the message to\nset new main auth descriptor\n\nwith flags:\n%s\n\nand signers:\n%s\n\nof account:\n{account_id}".format(flags, signers);
}

function update_main_auth_descriptor_resolver(args: gtv, account_id: byte_array, auth_descriptor_ids: list<byte_array>) {
    val main_auth_descriptor = require(
        accounts.main_auth_descriptor @? { .account.id == account_id } .auth_descriptor,
        "Account <%s> does not have main auth descriptor set".format(account_id)
    );

    return if (main_auth_descriptor.id in auth_descriptor_ids) main_auth_descriptor.id else null;
}

@extend(auth.auth_handler)
function () = auth.add_overridable_auth_handler(
    scope = rell.meta(update_main_auth_descriptor).mount_name,
    flags = [accounts.auth_flags.ACCOUNT],
    message = update_main_auth_descriptor_message(*),
    resolver = update_main_auth_descriptor_resolver(*)
);

/**
 * Sets provided auth descriptor as main auth descriptor, deleting the previous one.
 * 
 * Must be signed by an auth descriptor with `accounts.auth_flags.ACCOUNT` and it must
 * be signed by all the signers contained in the new auth descriptor. Any combination of
 * swapping single sig and multisig auth descriptors as main auth descriptor is valid, so long
 * as the number of signatures requirements are fulfilled.
 * 
 * Throws an error if the new auth descriptor has any other value than `GTV_NULL`
 * in the `rules` field.
 * 
 * Throws an error if the new auth descriptor does not have all the mandatory flags.
 * 
 * @see core.accounts.auth_flags_config for information on mandatory flags
 * 
 * @param new_desc  the auth descriptor which will become the new main auth descriptor of the
 *                  account.
 */
operation update_main_auth_descriptor(new_desc: accounts.auth_descriptor) {
    val account = auth.authenticate();
    auth.verify_signers(accounts.get_signers(new_desc));
    accounts.update_main_auth_descriptor(account, new_desc);
}
