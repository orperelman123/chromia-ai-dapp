
function init_transfer_message(gtv) {
    val params = struct<init_transfer>.from_gtv(gtv);
    val asset = assets.Asset(params.asset_id);

    return "Please sign the message\nto transfer %s %s\n\nfrom:\n-account {account_id}\n-chain: %s\n\nto:\n-account %s\n-chain: %s"
        .format(
            assets.format_amount_with_decimals(params.amount, asset.decimals),
            asset.name,
            chain_context.blockchain_rid,
            params.recipient_id,
            params.hops[params.hops.size()-1]
        );
}

@extend(auth.auth_handler)
function () = auth.add_overridable_auth_handler(
    scope = rell.meta(init_transfer).mount_name,
    flags = [accounts.auth_flags.TRANSFER],
    message = init_transfer_message(*)
);

/*
 * - sender account ID is equal to this chain's ID
 * Should we worry about this?
 */
/** 
 * Initializes a crosschain transfer, which is a transfer that goes to a different blockchain
 * on the Chromia network.
 * 
 * Since this chain cannot communicate with any other chain, it is up to the client to
 * perform the necessary steps to complete this transfer. Furthermore, this chain will
 * not validate if the sender is allowed to send assets to the target chain or if the
 * recipient account exists, meaning that when the client tries to apply the transfer
 * on the target chain, it might not be accepted. Should that happen, the sender can
 * recall their transfer after the deadline has expired.
 * 
 * Must be signed by an auth descriptor with `accounts.auth_flags.TRANSFER`
 * 
 * The functionality provided by `init_transfer` can be modified by extending
 * `before_init_transfer` and `after_init_transfer`
 * 
 * Throws `"INVALID RECIPIENT ID"` if the recipient's id length is longer than 1024 bytes
 * 
 * Throws `"`TRANSFER EXPIRED"` if deadline is a past timestamp
 * 
 * Throws `"MISSING ASSET"` if the asset does not exist on this chain
 * 
 * Throws `"HOPS SIZE EXCEEDED"` if the hops list size is not less than 100
 * 
 * Throws `"INVALID BRID"` if the hops RIDs length are not 32 bytes
 * 
 * Throws if additional conditions provided through extensions of `before_init_transfer` and
 * `after_init_transfer` are not satisfied
 * 
 * Throws if the first transfer is misconfigured. Common cases are:
 * - `hops[0]` is:
 *   - equal to the sender account ID
 *   - this blockchain's RID
 *   - the ID of an account on this chain which is not a blockchain account
 * - amount is:
 *   - not in the accepted range (0, 2^256) (exclusive)
 *   - higher than the account's balance
 * - sender account ID is equal to this chain's ID
 * 
 * Requires the Transfer flag to be present on the auth descriptor that authorizes this
 * operation.
 * 
 * @see core.crosschain.before_init_transfer to add custom logic before this operation
 * 
 * @see core.crosschain.after_init_transfer to add custom logic after this operation
 * 
 * @see core.crosschain.applied_transfers to know more about the crosschain transfer workflow
 * 
 * @see core.crosschain.ACCOUNT_TYPE_BLOCKCHAIN for more info on blockchain account entities
 *
 * @param recipient_id  the account that will receive the transfers on the final chain
 * @param asset_id      the ID of the asset that is being transferred
 * @param amount        the amount that is being transferred
 * @param hops          an array of all the blockchain rids which this transfer needs to
 *                      go through in order to reach the recipient on the target chain, which 
 *                      will be the last entry in the array. The rid of this blockchain must
 *                      not be included in the array.
 * @param deadline      Time in milliseconds for which this transfer is valid, if the
 *                      transfer were not completed within this deadline, it will be
 *                      possible for the sender to recall it.
 */
operation init_transfer(
    recipient_id: byte_array,
    asset_id: byte_array,
    amount: big_integer,
    hops: list<byte_array>,
    deadline: timestamp
) {
    require(
        deadline > op_context.last_block_time,
        "TRANSFER EXPIRED: Parameter 'deadline' cannot be a past timestamp. Value: %s".format(deadline)
    );

    utils.validate_recipient_id(recipient_id);

    val account = auth.authenticate();
    val asset = require(
        assets.asset @? { .id == asset_id }, 
        "MISSING ASSET: Asset not found '%s'".format(asset_id)
    );

    require(
        hops.size() <= crosschain.MAX_PATH_LENGTH,
        "HOPS SIZE EXCEEDED: Found <%d> hops, but the maximum size is <%d>".format(hops.size(), crosschain.MAX_PATH_LENGTH)
    );
    for (hop in hops) {
        utils.validate_blockchain_rid(hop);
    }

    crosschain.before_init_transfer(
        account,
        recipient_id,
        asset,
        amount,
        hops,
        deadline
    );

    crosschain.Unsafe.update_balances_if_needed(
        account,
        crosschain.ensure_blockchain_account(hops[0]),
        asset,
        amount
    );
    create assets.crosschain_transfer_history_entry(
        .blockchain_rid = hops[hops.size() - 1],
        .account_id = recipient_id,
        .asset = asset,
        .delta = amount,
        .op_index = op_context.op_index,
        .is_input = false
    );

    val pending_transfer = create crosschain.pending_transfer(
        sender = account,
        transaction = op_context.transaction,
        op_index = op_context.op_index
    );

    crosschain.after_init_transfer(
        account,
        recipient_id,
        asset,
        amount,
        hops,
        deadline,
        pending_transfer
    );
}

/**
 * This operation must be called on every chain listed in the `hops` array
 * provided to the `init_transfer` function which corresponds to this transfer.
 * 
 * When this is done, one of two things will happen:
 *  - If this is an intermediary hop, this chain will update its internal record of
 *    which chain that owns how much of what asset
 *  - If this is the final hop, the transferred amount will be credited to the recipient account
 * 
 * In the case where this is the last hop and the recipient account does not exist,
 * one of two things can happen:
 *  - If the create on transfer account creation strategy is enabled, the assets will be received and
 *    the recipient will be able create the account and claim them.
 *  - If the feature is not enabled, the transfer will be rejected, in which case, the sender can
 *    get their assets back by calling the `cancel_transfer` in the reverse hops order.
 * 
 * Anyone can call this operation on behalf of any transfer, but it needs to include an `iccf_proof`
 * operation which prove that the transaction was applied in the previous hop.
 * 
 * The functionality provided by `apply_transfer` can be modified by extending
 * `before_apply_transfer` and `after_apply_transfer`
 * 
 * Throws `"`TRANSFER EXPIRED"` if deadline is a past timestamp
 * 
 * Throws `"MISSING ACCOUNT"` if all these conditions apply:
 * - this chain is the last chain in the crosschain transaction
 * - the account corresponding to `recipient_id` does not exist
 * - creating account on crosschain transfer is not enabled on this chain
 * 
 * Throws if additional conditions provided through extensions of `before_apply_transfer` and
 * `after_apply_transfer` are not satisfied
 * 
 * Throws if the current transfer is misconfigured. Common cases are:
 * - the next hop or the previous one are:
 *   - equal to one another
 *   - this blockchain's RID
 *   - the ID of an account on this chain which is not a blockchain account
 * - amount is:
 *   - not in the accepted range (0, 2^256) (exclusive)
 *   - higher than the blockchain account balance they're coming from
 * - the asset is not registered on this chain
 * - input is malformed:
 *   - arguments found in `init_transfer_tx` and `previous_hop_tx` do not match
 *   - `hop_index` is out of bounds
 *   - `previous_hop_tx` has not been sent to the chain that comes before this one on the transfer
 *     hops
 * - the transfer has already been applied, canceled or unapplied on this chain.
 * - the chain at `hop_index` on the init transaction is not this chain
 * - the `op_index` on `previous_hop_tx` does not point to:
 *   - `init_transfer` when `hop_index` is 0
 *   - `apply_transfer` otherwise
 * - the `init_tx_op_index` does not point to `init_transfer` on its `init_transfer_tx`
 * - the operation preceding `init_transfer` is not an auth operation
 * 
 * Throws if all these conditions apply:
 * - this chain is the last chain in the crosschain transaction
 * - the account corresponding to `recipient_id` does not exist
 * - creating account on crosschain transfer is enabled on this chain
 * - the function implementing the account creation strategy being used (extension of 
 *   `create_on_crosschain_transfer`) has conditions which are not satisfied
 * 
 * Throws if the transaction is missing the `iccf_proof` operation, which demonstrates that
 * the block containing the `previous_hop_tx` has been anchored from the previous chain.
 * 
 * Requires no flags - no authorization is performed to apply a transfer.
 * 
 * @see core.auth.is_auth_op for information on auth operations
 * 
 * @see core.crosschain.before_apply_transfer to add custom logic before this operation
 * 
 * @see core.crosschain.after_apply_transfer to add custom logic after this operation
 * 
 * @see core.crosschain.applied_transfers to know more about the crosschain transfer workflow
 * 
 * @see core.crosschain.is_create_on_crosschain_transfer_enabled to know more about account
 * creation on crosschain transfer
 * 
 * @param init_transfer_tx  the `gtx_transaction` that represents the tx containing the
 *                          `init_transfer` operation on the initial chain
 * @param init_tx_op_index  the index of the `init_transfer` operation in `init_transfer_tx`
 * @param previous_hop_tx   the tx containing the `init_transfer` or `apply_transfer` operation
 *                          from the previous step. In the first hop, `init_transfer_tx` and this
 *                          argument will be the same
 * @param op_index          the index of the `apply_transfer` operation in `previous_hop_tx`
 * @param hop_index         which index in the hops array provided in the original transaction this
 *                          chain represents.
 */
operation apply_transfer(
    init_transfer_tx: gtx_transaction,
    init_tx_op_index: integer,
    previous_hop_tx: gtx_transaction,
    op_index: integer,
    hop_index: integer
) {
    val (init_transfer_details, from_blockchain_rid) = validate_apply_transfer(
        init_transfer_tx,
        init_tx_op_index,
        previous_hop_tx,
        op_index,
        hop_index
    );

    require(
        init_transfer_details.args.deadline >= op_context.last_block_time,
        "TRANSFER EXPIRED: This transfer has expired at timestamp <%s> (evaluated at timestamp <%s>). It can only be reverted."
            .format(init_transfer_details.args.deadline, op_context.last_block_time)
    );

    val asset = assets.Asset(init_transfer_details.args.asset_id);

    val is_intermediate = init_transfer_details.args.hops.size() > hop_index + 1;

    crosschain.before_apply_transfer(
        sender_blockchain_rid = init_transfer_tx.body.blockchain_rid,
        sender_account_id = init_transfer_details.sender_account_id,
        recipient_id = init_transfer_details.args.recipient_id,
        asset = asset,
        amount = init_transfer_details.args.amount,
        hop_index = hop_index,
        is_final = not is_intermediate
    );

    if (is_intermediate) {
        // this hop is not last
        val next_hop = init_transfer_details.args.hops[hop_index + 1];
        crosschain.Unsafe.update_balances_if_needed(
            crosschain.ensure_blockchain_account(from_blockchain_rid),
            crosschain.ensure_blockchain_account(next_hop),
            asset,
            init_transfer_details.args.amount
        );
    } else {
        // final hop -- send money to recipient account
        val recipient = accounts.account @? { .id == init_transfer_details.args.recipient_id };
        if (recipient != null) {
            crosschain.Unsafe.update_balances_if_needed(
                crosschain.ensure_blockchain_account(from_blockchain_rid),
                recipient,
                asset,
                init_transfer_details.args.amount
            );
        } else {
            require(crosschain.is_create_on_crosschain_transfer_enabled(),
                "MISSING ACCOUNT: Account <%s> does not exist and creating accounts on transfer is not enabled"
                    .format(init_transfer_details.args.recipient_id));
            crosschain.create_on_crosschain_transfer(
                init_transfer_tx.body.blockchain_rid,
                init_transfer_details.sender_account_id,
                init_transfer_details.args.recipient_id,
                asset,
                init_transfer_details.args.amount
            );
        }
        create assets.crosschain_transfer_history_entry(
            .blockchain_rid = init_transfer_tx.body.blockchain_rid,
            .account_id = init_transfer_details.sender_account_id,
            .asset = asset,
            .delta = init_transfer_details.args.amount,
            .op_index = op_context.op_index,
            .is_input = true
        );
    }

    // Add transfer to applied transfers table so that it cannot be applied more than once
    val applied_transfer = create crosschain.applied_transfers(
        init_tx_rid = init_transfer_details.tx_rid,
        init_op_index = init_tx_op_index,
        transaction = op_context.transaction,
        op_index = op_context.op_index
    );

    crosschain.after_apply_transfer(
        sender_blockchain_rid = init_transfer_tx.body.blockchain_rid,
        sender_account_id = init_transfer_details.sender_account_id,
        recipient_id = init_transfer_details.args.recipient_id,
        asset = asset,
        amount = init_transfer_details.args.amount,
        hop_index = hop_index,
        is_final = not is_intermediate,
        applied_transfers = applied_transfer
    );
}

/**
 * This operation is to be called on the initial chain (the chain for which a crosschain
 * transfer originated) once all hops are completed and the transfer has been successfully
 * delivered to the recipient. Even if this operation is not called, the recipient will still
 * receive their assets, but calling this operation will allow clients to stop displaying it 
 * as ongoing to the user that sent it.
 * 
 * Anyone can call this operation, but it needs to include an `iccf_proof` operation that the
 * final `apply_transfer` was performed.
 * 
 * Throws `"`INPUT ERROR"` if `op_index` does not point to an `apply_transfer` operation
 * 
 * Throws `"INCOMPLETE TRANSFER"` if the given `apply_transfer` was not called on the last
 * chain; that is, if the `hop_index` parameter does not correspond to the last hop index.
 * 
 * Throws `"WRONG DESTINATION"` if the given `apply_transfer` was called on a chain that does
 * not correspond to the `init_transfer`'s last chain in the `hops` parameter
 * 
 * Throws if the transaction is missing the `iccf_proof` operation, which demonstrates that
 * the block containing the `final_apply_transfer_tx` has been anchored from the target chain.
 * 
 * Requires no flags - no authorization is performed to complete a transfer.
 * 
 * @param final_apply_transfer_tx   the transaction that was submitted and applied on the target chain
 *                                  in order to complete the crosschain transfer.
 * @param op_index                  the index for the `apply_transfer` operation in question in 
 *                                  `final_apply_transfer_tx`
 */
operation complete_transfer(
    final_apply_transfer_tx: gtx_transaction,
    op_index: integer
) {
    require(
        final_apply_transfer_tx.body.operations[op_index].name == rell.meta(apply_transfer).mount_name,
        "INPUT ERROR: Operation at op_index was not apply_transfer"
    );

    // map gtv args to struct
    val final_apply_transfer_args = struct<apply_transfer>.from_gtv(final_apply_transfer_tx.body.operations[op_index].args.to_gtv());

    // extract init transfer tx details
    val init_transfer_tx_hash = final_apply_transfer_args.init_transfer_tx.to_gtv().hash();
    val init_transfer_args = struct<init_transfer>.from_gtv(final_apply_transfer_args.init_transfer_tx.body.operations[final_apply_transfer_args.init_tx_op_index].args.to_gtv());

    require(
        final_apply_transfer_args.hop_index == init_transfer_args.hops.size() - 1,
        "INCOMPLETE TRANSFER: The provided transaction does not represent the final hop in this cross chain transfer"
    );
    require(
        init_transfer_args.hops[final_apply_transfer_args.hop_index] == final_apply_transfer_tx.body.blockchain_rid,
        "WRONG DESTINATION: The provided transaction was not applied to the expected target chain"
    );

    iccf.require_valid_proof(
        final_apply_transfer_tx,
        require_anchored_proof=true,
        verify_signers=false
    );

    // delete the pending transfer as it is now completed
    delete crosschain.pending_transfer @ { .transaction.tx_hash == init_transfer_tx_hash, .op_index == final_apply_transfer_args.init_tx_op_index };
}

/**
 * Cancels a crosschain transfer that has expired. This operation must be called in place
 * of `apply_transfer` to start the transfer canceling process. `unapply_transfer` must
 * then be called on all previous chains to bring the funds back to the sender account.
 * 
 * Throws `"TRANSFER NOT EXPIRED"` if the transfer has not yet expired.
 * 
 * Throws in various cases of misconfiguration. Some examples:
 * - the transfer has already been applied, canceled or unapplied on this chain.
 * - the chain at `hop_index` on the init transaction is not this chain
 * - the `op_index` on `previous_hop_tx` does not point to:
 *   - `init_transfer` when `hop_index` is 0
 *   - `apply_transfer` otherwise
 * - the `init_tx_op_index` does not point to `init_transfer` on its `init_transfer_tx`
 * - the operation preceding `init_transfer` is not an auth operation
 * - arguments found in `init_transfer_tx` and `previous_hop_tx` do not match
 * - `hop_index` is out of bounds
 * - `previous_hop_tx` has not been sent to the chain that comes before this one on the
 *   transfer hops
 * 
 * Throws if the transaction is missing the `iccf_proof` operation, which demonstrates that
 * the block containing the `previous_hop_tx` has been anchored from the previous chain.
 * 
 * Anyone can call this operation, but it needs to include an `iccf_proof` operation that
 * `apply_transfer` was performed on the previous chain.
 * 
 * @see core.auth.is_auth_op for information on auth operations
 * 
 * @see core.crosschain.applied_transfers to know more about the crosschain transfer workflow
 * 
 * @see core.crosschain.canceled_transfers to know more about transfer canceling
 * 
 * @see crosschain.unapply_transfer for information on 
 * 
 * @param init_transfer_tx  the transaction containing the `init_transfer` operation which 
 *                          corresponds to the transfer to cancel
 * @param init_tx_op_index  the index of the `init_transfer` operation in `init_transfer_tx`
 * @param previous_hop_tx   the transaction containing the `apply_transfer` operation of the previous hop
 * @param op_index          the index of the `apply_transfer` or `init_transfer` operation
 *                          in `previous_hop_tx`
 * @param hop_index         which index in the hops array provided in the original transaction this
 *                          chain represents.
 */
operation cancel_transfer(
    init_transfer_tx: gtx_transaction,
    init_tx_op_index: integer,
    previous_hop_tx: gtx_transaction,
    op_index: integer,
    hop_index: integer
) {
    val (init_transfer_details, from_blockchain_rid) = validate_apply_transfer(
        init_transfer_tx,
        init_tx_op_index,
        previous_hop_tx,
        op_index,
        hop_index
    );

    require(
        init_transfer_details.args.deadline < op_context.last_block_time,
        "TRANSFER NOT EXPIRED: This transfer has not yet expired. It can not be reverted before <%s> (evaluated at timestamp <%s>)."
            .format(init_transfer_details.args.deadline, op_context.last_block_time)
    );

    create crosschain.canceled_transfers(init_transfer_details.tx_rid, init_tx_op_index);
}

/**
 * Unapplies a crosschain transfer that has expired. This operation must be called if
 * `apply_transfer` was already executed on this chain. To successfully unapply a transfer,
 * it must have been:
 * - canceled or any later hop (including the target chain), or
 * - recalled on the target chain. 
 * This operation should not be called on the init chain - `revert_transfer` should be used
 * instead.
 * 
 * Throws `"INVALID TRANSFER"` if the transfer that is being unapplied was:
 * - never applied on this chain
 * - already canceled or unapplied
 * 
 * Throws `"INPUT ERROR"` if the input is malformed. This could be one of many different things:
 * - arguments found in `init_transfer_tx` and `last_tx` do not match
 * - `hop_index` is out of bounds or points to a different chain than this one
 * - `hop_index` points to the target chain, where canceling or recall should happen (not unapplying)
 * - `last_tx` has not been sent to the chain that comes after this one on the transfer hops
 * 
 * Throws`"UNSUPPORTED LAST OP"` if the operation found in `last_tx` at the given index is
 * neither of the three supported operations:
 * - `cancel_transfer` if the transfer was canceled before being applied on the chain that
 *   came after this one on the transfer hops
 * - `recall_unclaimed_transfer` if the transfer was applied on the target chain, it was sent
 *   to a non-existing account, and it has expired
 * - `unapply_transfer` if the transfer was canceled or recalled, and then unapplied on another
 *   chain before reaching this one
 * 
 * Throws `"TRANSFER NOT EXPIRED"` if the transfer being reverted did not expire
 * 
 * Throws if the `init_tx_op_index` does not point to `init_transfer` on `init_transfer_tx`
 * 
 * Throws if the required assets cannot be transferred. While this could throw in all cases
 * of misconfiguration considered possible for `apply_transfer`, to unapply a transfer it must
 * first have been applied. This means that the most probable scenario for the transfer of
 * funds to fail is if the sender blockchain account balance is lower than `amount`.
 * 
 * Other cases considered possible for `apply_transfer` are still possible, although unlikely.
 * For example, the asset entity could have been deleted, which means that the asset is no
 * longer registered on this chain.
 * 
 * Requires no flags - no authorization is performed to unapply a transfer.
 * 
 * @see apply_transfer for edge cases where this operation might throw
 * 
 * @see core.crosschain.applied_transfers to know more about the crosschain transfer workflow
 * 
 * @see core.crosschain.unapplied_transfers to know more about transfer unapplying
 * 
 * @see core.crosschain.canceled_transfers to know more about transfer canceling
 * 
 * @see core.crosschain.recalled_transfers to know more about transfer recall
 * 
 * @param init_transfer_tx  the transaction containing the `init_transfer` operation which 
 *                          corresponds to the transfer to unapply
 * @param init_tx_op_index  the index of the `init_transfer` operation in `init_transfer_tx`
 * @param last_tx           the last transaction in this transfer flow, as sent to the previous hop.
 *                          Note that "previous" in this context refers to the chain at n + 1 in the
 *                          hops array in relation to this blockchain, since we are walking the hops
 *                          array backwards.
 *                          It must contain one of the three supported operations described above.
 * @param last_op_index     the index of the supported operation in `last_tx`
 * @param hop_index         which index in the hops array provided in the original transaction this
 *                          chain represents.
 */
operation unapply_transfer(
    init_transfer_tx: gtx_transaction,
    init_tx_op_index: integer,
    last_tx: gtx_transaction,
    last_op_index: integer,
    hop_index: integer
) {
    val init_transfer_details = get_init_transfer_details(init_transfer_tx, init_tx_op_index);

    val (apply_tx_data, apply_op_index) = require_not_empty(
        crosschain.applied_transfers @? { .init_tx_rid == init_transfer_details.tx_rid, .init_op_index == init_tx_op_index} (.transaction.tx_data, .op_index),
        "INVALID TRANSFER: Transaction <%s> transfer at index <%s> was never applied on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    require(
        crosschain.canceled_transfers @? {init_transfer_details.tx_rid, init_tx_op_index} == null,
        "INVALID TRANSFER: Transaction <%s> transfer at index <%s> has already been canceled on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    require(
        crosschain.unapplied_transfers @? {init_transfer_details.tx_rid, init_tx_op_index} == null,
        "INVALID TRANSFER: Transaction <%s> transfer at index <%s> has already been unapplied on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    val last_op = last_tx.body.operations[last_op_index];

    when (last_op.name) {
        rell.meta(cancel_transfer).mount_name -> {
            val args = struct<cancel_transfer>.from_gtv(last_op.args.to_gtv());
            require(
                init_transfer_tx == args.init_transfer_tx,
                "INPUT ERROR: init_transfer_tx must match argument of last_tx"
            );
            require(
                init_tx_op_index == args.init_tx_op_index,
                "INPUT ERROR: init_tx_op_index must match argument of last_tx"
            );
            require(
                args.previous_hop_tx.to_bytes() == apply_tx_data,
                "INPUT ERROR: last_tx's previous_hop_tx must be the apply_transfer to cancel"
            );
            require(
                args.op_index == apply_op_index,
                "INPUT ERROR: last_tx's op_index must be the apply_transfer to cancel"
            );
        }
        rell.meta(unapply_transfer).mount_name -> {
            val args = struct<unapply_transfer>.from_gtv(last_op.args.to_gtv());
            require(
                init_transfer_tx == args.init_transfer_tx,
                "INPUT ERROR: init_transfer_tx must match argument of last_tx"
            );
            require(
                init_tx_op_index == args.init_tx_op_index,
                "INPUT ERROR: init_tx_op_index must match argument of last_tx"
            );
        }
        rell.meta(recall_unclaimed_transfer).mount_name -> {
            val args = struct<recall_unclaimed_transfer>.from_gtv(last_op.args.to_gtv());
            require(
                init_transfer_tx == args.init_transfer_tx,
                "INPUT ERROR: init_transfer_tx must match argument of last_tx"
            );
            require(
                init_tx_op_index == args.init_tx_op_index,
                "INPUT ERROR: init_tx_op_index must match argument of last_tx"
            );
        }
        else -> {
            require(false, "UNSUPPORTED LAST OP: last_tx[last_op_index] must be %s, %s or %s".format(
                rell.meta(cancel_transfer).mount_name, rell.meta(unapply_transfer).mount_name, rell.meta(recall_unclaimed_transfer).mount_name)
            );
        }
    }

    require( 
        init_transfer_details.args.hops.size() > hop_index,
        /* wrong! it's **SMALLER** */
        "INPUT ERROR: Argument mismatch: init_transfer hops size (%d) is greater than hop_index (%d)"
            .format(init_transfer_details.args.hops.size(), hop_index)
    );

    require(
        init_transfer_details.args.hops.size() - 1 != hop_index,
        "INPUT ERROR: Cannot unapply last step (%d)".format(hop_index)
    );

    val current_hop_blockchain_rid = init_transfer_details.args.hops[hop_index];
    require(
        current_hop_blockchain_rid == chain_context.blockchain_rid,
        "INPUT ERROR: This transaction hop must happen on a chain with blockchain_rid %s".format(current_hop_blockchain_rid)
    );

    val next_hop_blockchain_rid = init_transfer_details.args.hops[hop_index + 1];
    require(
        last_tx.body.blockchain_rid == next_hop_blockchain_rid,
        "INPUT ERROR: Argument mismatch: next hops (%s) and tx blockchain_rid (%s) don't correspond"
            .format(
                next_hop_blockchain_rid, last_tx.body.blockchain_rid
            )
    );

    require(
        init_transfer_details.args.deadline < op_context.last_block_time,
        "TRANSFER NOT EXPIRED: This transfer has not yet expired. It can not be reverted before <%s> (evaluated at timestamp <%s>)."
            .format(init_transfer_details.args.deadline, op_context.last_block_time)
    );

    iccf.require_valid_proof(
        last_tx,
        require_anchored_proof=true,
        verify_signers=false
    );

    val asset = assets.Asset(init_transfer_details.args.asset_id);
    val previous_hop = if (hop_index > 0) init_transfer_details.args.hops[hop_index - 1] else init_transfer_tx.body.blockchain_rid;
    crosschain.Unsafe.update_balances_if_needed(
        crosschain.ensure_blockchain_account(next_hop_blockchain_rid),
        crosschain.ensure_blockchain_account(previous_hop),
        asset,
        init_transfer_details.args.amount
    );

    create crosschain.unapplied_transfers(init_transfer_details.tx_rid, init_tx_op_index);
}

/**
 * Reverts a transfer that was initialized on this chain, after it has expired.
 * If a crosschain transfer is to be rolled back after expiring and the
 * assets are to be returned to the original sender, after the process
 * of walking the path backwards until the source chain, then this operation
 * should be called as the final step on the source chain to complete the
 * rollback. When this operation is called, the assets are returned back
 * to the original sender.
 * 
 * Throws `"INVALID TRANSFER"` if the transfer that is being unapplied was:
 * - never initialized on this chain
 * - already reverted on this chain
 * 
 * Throws `"INPUT ERROR"` if the input is malformed. This could be one of many different things:
 * - arguments found in `init_transfer_tx` and `last_tx` do not match
 * - `last_tx` has not been sent to the chain that comes after this one on the transfer hops
 * 
 * Throws`"UNSUPPORTED LAST OP"` if the operation found in `last_tx` at the given index is
 * neither of the three supported operations:
 * - `unapply_transfer` if the transfer was canceled or recalled, but it had more than one hop
 *   (i.e. it went from starting chain to target chain while going through at least another chain)
 * - `cancel_transfer` if the transfer was canceled before being applied on the chain that came
 *   after the init chain
 * - `recall_unclaimed_transfer` if the transfer was applied on the target chain, it was sent
 *   to a non-existing account, and it has expired
 * 
 * Throws `"TRANSFER NOT EXPIRED"` if the transfer being reverted did not expire
 * 
 * Throws if the `init_tx_op_index` does not point to `init_transfer` on `init_transfer_tx`
 * 
 * Throws if the required assets cannot be transferred. While this could throw in all cases
 * of misconfiguration considered possible for `init_transfer`, to revert a transfer it must
 * first have been applied. This means that the most probable scenario for the transfer of
 * funds to fail is if the sender blockchain account balance is lower than `amount`.
 * 
 * Other cases considered possible for `init_transfer` are still possible, although unlikely.
 * For example, the asset entity could have been deleted, which means that the asset is no
 * longer registered on this chain.
 * 
 * Anyone can call this operation, but it needs to include an `iccf_proof` operation that
 * `unapply_transfer` was performed on the previous chain.
 * 
 * @see core.crosschain.applied_transfers to know more about the crosschain transfer workflow
 * 
 * @see core.crosschain.reverted_transfers to know more about transfer reversal
 * 
 * @param init_transfer_tx  the transaction containing the `init_transfer` operation which 
 *                          corresponds to the transfer to revert
 * @param init_tx_op_index  the index of the `init_transfer` operation in `init_transfer_tx`
 * @param last_tx           the last transaction in this transfer flow, as sent to the previous hop.
 *                          Note that "previous" in this context refers to the chain at n + 1 in the
 *                          hops array in relation to this blockchain, since we are walking the hops
 *                          array backwards.
 *                          It must contain one of the three supported operations described above.
 * @param last_op_index     the index of `apply_transfer` operation in `last_tx`
 */
operation revert_transfer(
    init_transfer_tx: gtx_transaction,
    init_tx_op_index: integer,
    last_tx: gtx_transaction,
    last_op_index: integer
) {
    val init_transfer_details = get_init_transfer_details(init_transfer_tx, init_tx_op_index);
    val hops = init_transfer_details.args.hops;

    val account = accounts.Account(init_transfer_details.sender_account_id);
    val asset = assets.Asset(init_transfer_details.args.asset_id);
    val amount = init_transfer_details.args.amount;

    val next_hop_blockchain_rid = hops[0];
    require(
        last_tx.body.blockchain_rid == next_hop_blockchain_rid,
        "INPUT ERROR: Argument mismatch: next hops (%s) and tx blockchain_rid (%s) don't correspond"
            .format(
                next_hop_blockchain_rid, last_tx.body.blockchain_rid
            )
    );

    require(
        init_transfer_details.args.deadline < op_context.last_block_time,
        "TRANSFER NOT EXPIRED: This transfer has not yet expired. It can not be reverted before <%s> (evaluated at timestamp <%s>)."
            .format(init_transfer_details.args.deadline, op_context.last_block_time)
    );

    val last_op = last_tx.body.operations[last_op_index];

    when (last_op.name) {
        rell.meta(cancel_transfer).mount_name -> {
            val args = struct<cancel_transfer>.from_gtv(last_op.args.to_gtv());
            require(
                init_transfer_tx == args.init_transfer_tx,
                "INPUT ERROR: init_transfer_tx must match argument of last_tx"
            );
            require(
                init_tx_op_index == args.init_tx_op_index,
                "INPUT ERROR: init_tx_op_index must match argument of last_tx"
            );
        }
        rell.meta(unapply_transfer).mount_name -> {
            val args = struct<unapply_transfer>.from_gtv(last_op.args.to_gtv());
            require(
                init_transfer_tx == args.init_transfer_tx,
                "INPUT ERROR: init_transfer_tx must match argument of last_tx"
            );
            require(
                init_tx_op_index == args.init_tx_op_index,
                "INPUT ERROR: init_tx_op_index must match argument of last_tx"
            );
        }
        rell.meta(recall_unclaimed_transfer).mount_name -> {
            val args = struct<recall_unclaimed_transfer>.from_gtv(last_op.args.to_gtv());
            require(
                init_transfer_tx == args.init_transfer_tx,
                "INPUT ERROR: init_transfer_tx must match argument of last_tx"
            );
            require(
                init_tx_op_index == args.init_tx_op_index,
                "INPUT ERROR: init_tx_op_index must match argument of last_tx"
            );
        }
        else -> {
            require(false, "INPUT ERROR: last_tx[last_op_index] must be %s, %s or %s".format(
                rell.meta(cancel_transfer).mount_name, rell.meta(unapply_transfer).mount_name, rell.meta(recall_unclaimed_transfer).mount_name)
            );
        }
    }

    iccf.require_valid_proof(
        last_tx,
        require_anchored_proof=true,
        verify_signers=false
    );

    require(
        crosschain.reverted_transfer @? { .init_tx_rid == init_transfer_details.tx_rid, .init_op_index == init_tx_op_index } == null,
        "INVALID TRANSFER: Transaction <%s> transfer at index <%s> has already been reverted on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    require(
      transaction @? { .tx_rid == init_transfer_details.tx_rid },
      "INVALID TRANSFER: Cannot revert cross-chain transfer for transaction <%s> at index <%d>. init_transfer not found."
          .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    // delete any pending transfer as it is now reverted
    delete crosschain.pending_transfer @? { .transaction.tx_rid == init_transfer_details.tx_rid, .op_index == init_tx_op_index };

    crosschain.Unsafe.update_balances_if_needed(
        crosschain.ensure_blockchain_account(hops[0]),
        account,
        asset,
        amount
    );
    create assets.crosschain_transfer_history_entry(
        .blockchain_rid = hops[hops.size() - 1],
        .account_id = init_transfer_details.args.recipient_id,
        .asset = asset,
        .delta = amount,
        .op_index = op_context.op_index,
        .is_input = true
    );

    create crosschain.reverted_transfer(init_tx_rid = init_transfer_details.tx_rid, init_op_index = init_tx_op_index);
}

/**
 * Recalls an unclaimed transfer. A transfer does not generally need to be claimed, unless
 * account registration on crosschain transfers is configured on the target chain.
 * 
 * If it is, when a crosschain transfer is sent to that chain and the recipient account does
 * not exist, the transfer is considered the start of an account registration process. The
 * account is not automatically created, and account registration strategies must be used to
 * claim the transfer and create an account.
 * 
 * If this is not done within the transfer deadline, the transfer can be recalled on the
 * target chain, unapplied on all intermediate chains if any, and reverted on the init chain
 * to move the funds back to the original sender.
 * 
 * Throws `"ACCOUNT REGISTRATION DISABLED"` if this chain is not configured to allow account
 * registration on crosschain transfers. This means that a transfer can never end up unclaimed.
 * 
 * Throws `"WRONG BLOCKCHAIN"` if the transfer has a target chain different from this one.
 * 
 * Throws `"INVALID TRANSACTION"` if the transaction has either:
 * - never been applied here
 * - already been recalled
 *
 * Throws if any conditions on the recall of crosschain account registration (defined as 
 * extensions to `recall_on_crosschain_transfer`) are not met
 * 
 * Throws if `init_tx_op_index` does not point to `init_transfer` on `init_transfer_tx`
 * 
 * Throws if the operation preceding the `init_transfer` on `init_transfer_tx` is not an
 * auth operation
 * 
 * This operation can be called by anyone after the timeout has expired.
 * 
 * @see core.auth.is_auth_op for information on auth operations
 * 
 * @see core.crosschain.applied_transfers to know more about the crosschain transfer workflow
 * 
 * @see core.crosschain.recalled_transfers to know more about transfer recalling
 * 
 * @see core.crosschain.create_on_crosschain_transfers for more information on registering
 * accounts with crosschain transfers
 * 
 * @see core.accounts.strategies.register_account for more information on register account
 * strategies
 * 
 * 
 * @param init_transfer_tx  the init transaction, which contains `init_transfer`, as it was
 *                          submitted to the init chain
 * @param init_tx_op_index  the index of the `init_transfer` operation in `init_transfer_tx`
 */
operation recall_unclaimed_transfer(
    init_transfer_tx: gtx_transaction,
    init_tx_op_index: integer)
{
    require(
        crosschain.is_create_on_crosschain_transfer_enabled(),
        "ACCOUNT REGISTRATION DISABLED: Creating accounts on transfer is not enabled"
    );

    val init_transfer_details = get_init_transfer_details(init_transfer_tx, init_tx_op_index);

    val last_hop_blockchain_rid = init_transfer_details.args.hops[init_transfer_details.args.hops.size()-1];
    require(
        last_hop_blockchain_rid == chain_context.blockchain_rid,
        "WRONG BLOCKCHAIN: This transaction must happen on a chain with blockchain_rid %s".format(last_hop_blockchain_rid)
    );

    val apply_tx = require(
        crosschain.applied_transfers @? { .init_tx_rid == init_transfer_details.tx_rid, .init_op_index == init_tx_op_index },
        "INVALID TRANSACTION: Transaction <%s> transfer at index <%s> has not been applied on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    require(
        crosschain.recalled_transfers @? { init_transfer_details.tx_rid, init_tx_op_index } == null,
        "INVALID TRANSACTION: Transaction <%s> transfer at index <%s> has already been recalled on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    val asset = assets.Asset(init_transfer_details.args.asset_id);

    crosschain.recall_on_crosschain_transfer(
        init_transfer_tx.body.blockchain_rid,
        init_transfer_details.sender_account_id,
        apply_tx.transaction.tx_rid,
        apply_tx.op_index
    );

    create assets.crosschain_transfer_history_entry(
        blockchain_rid = init_transfer_tx.body.blockchain_rid,
        account_id = init_transfer_details.sender_account_id,
        asset = asset,
        delta = init_transfer_details.args.amount,
        op_index = op_context.op_index,
        is_input = false
    );

    create crosschain.recalled_transfers(init_transfer_details.tx_rid, init_tx_op_index);
}

/**
 * Validates that the parameters are correct for an `apply_transfer` operation. Also used in
 * other operations that require the same validation to occur (e.g. `cancel_transfer`)
 * It does not verify whether the transfer expired.
 * 
 * Among other things, this function validates that:
 *  - Transfer was not already applied on this chain
 *  - Transfer was not already canceled on this chain
 *  - Transfer was not already unapplied on this chain
 *  - That the `init_transfer` details are correct
 *  - The `iccf_proof` that states that this transfer was applied on the previous hop
 * 
 * Throws `"INVALID TRANSACTION"` if the transfer has already been applied, canceled or
 * unapplied on this chain.
 * 
 * Throws `"INPUT ERROR"` if the input is malformed. Common scenarios include:
 * - arguments found in `init_transfer_tx` and `previous_hop_tx` do not match
 * - `hop_index` is out of bounds
 * - `previous_hop_tx` has not been sent to the chain that comes before this one on the
 *   transfer hops
 * 
 * Throws `"WRONG BLOCKCHAIN"` if the chain at `hop_index` on the init transaction is not this
 * chain
 * 
 * Throws if the `op_index` does not point to `apply_transfer`
 * 
 * Throws if the `init_tx_op_index` does not point to `init_transfer` on its `init_transfer_tx`
 * 
 * Throws if the operation preceding `init_transfer` is not an auth operation
 * 
 * Throws if the transaction is missing the `iccf_proof` operation, which demonstrates that
 * the block containing the `previous_hop_tx` has been anchored from the previous chain.
 * 
 * @see core.auth.is_auth_op for information on auth operations
 * 
 * @param init_transfer_tx  the init transaction, which contains `init_transfer`, as it was
 *                          submitted to the starting chain
 * @param init_tx_op_index  the index of the `init_transfer` operation in `init_transfer_tx`
 * @param previous_hop_tx   the transaction that applied the transfer in the chain that comes
 *                          before this one. Same as `init_transfer_tx` if this is the first
 *                          chain where the transfer is applied.
 * @param op_index          the index of the `apply_transfer` operation in `previous_hop_tx`
 * @param hop_index         which index in the hops array provided in the original transaction this
 *                          chain represents.
 */
function validate_apply_transfer(
    init_transfer_tx: gtx_transaction,
    init_tx_op_index: integer,
    previous_hop_tx: gtx_transaction,
    op_index: integer,
    hop_index: integer
) {
    val init_transfer_details = get_init_transfer_details(init_transfer_tx, init_tx_op_index);

    require(
        crosschain.applied_transfers @? { .init_tx_rid == init_transfer_details.tx_rid, .init_op_index == init_tx_op_index} == null,
        "INVALID TRANSACTION: Transaction <%s> transfer at index <%s> has already been applied on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    require(
        crosschain.canceled_transfers @? {init_transfer_details.tx_rid, init_tx_op_index} == null,
        "INVALID TRANSACTION: Transaction <%s> transfer at index <%s> has already been canceled on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    require(
        crosschain.unapplied_transfers @? {init_transfer_details.tx_rid, init_tx_op_index} == null,
        "INVALID TRANSACTION: Transaction <%s> transfer at index <%s> has already been unapplied on this chain."
            .format(init_transfer_details.tx_rid, init_tx_op_index)
    );

    if (hop_index == 0) {
        /*
         * For the first hop init_transfer_tx and previous_hop_tx are equal.
         * Consider making previous_hop_tx optional, so that we don't have to send the same transaction twice.
         */

        require(
            init_transfer_tx == previous_hop_tx,
            "INPUT ERROR: Invalid parameter. Previous hop tx must be equal to init transfer tx"
        );

        require(
            op_index == init_tx_op_index,
            "INPUT ERROR: Invalid parameter. init_transfer indices should be same"
        );
    } else {
        val previous_hop_details = get_apply_transfer_details(previous_hop_tx, op_index);

        require(
            init_transfer_details.tx_rid == previous_hop_details.init.tx_rid,
            "INPUT ERROR: apply_transfer of previous hop does not correspond to init_transfer"
        );

        require(
            init_tx_op_index == previous_hop_details.args.init_tx_op_index,
            "INPUT ERROR: This transfer does not correspond to transfer of provided previous hop"
        );
    }

    require(
        init_transfer_details.args.hops.size() > hop_index,
        // WRONG! IS SMALLER
        "INPUT ERROR: Argument mismatch: init_transfer hops size (%d) is greater than hop_index (%d)".format(init_transfer_details.args.hops.size(), hop_index)
    );

    val current_hop_blockchain_rid = init_transfer_details.args.hops[hop_index];
    require(
        current_hop_blockchain_rid == chain_context.blockchain_rid,
        "WRONG BLOCKCHAIN: This transaction hop must happen on a chain with blockchain_rid %s".format(current_hop_blockchain_rid)
    );

    val from_blockchain_rid = previous_hop_tx.body.blockchain_rid;

    if (hop_index > 0) {
        val previous_hop_blockchain_rid = init_transfer_details.args.hops[hop_index - 1];
        require(
            from_blockchain_rid == previous_hop_blockchain_rid,
            "INPUT ERROR: Argument mismatch: init_transfer hops (%s) and tx blockchain_rid (%s) don't correspond"
                .format(
                    previous_hop_blockchain_rid, from_blockchain_rid
                )
        );
    }

    iccf.require_valid_proof(
        previous_hop_tx,
        require_anchored_proof=true,
        verify_signers=false
    );

    return (init_transfer_details, from_blockchain_rid);
}

/**
 * Given a transaction that contains the `init_transfer` operation and the index it's at, this
 * function retrieves the transaction RID, the arguments to the `init_transfer` operation and
 * the ID of the sender account.
 * 
 * Throws `"INIT TRANSFER NOT FOUND"` if the `op_index` does not point to `init_transfer` on
 * `tx`
 * 
 * Throws if the operation preceding the `init_transfer` is not an auth operation
 * 
 * @see core.auth.is_auth_op for information on auth operations
 * 
 * @param tx        the transaction containing the `init_transfer` operation
 * @param op_index  the index of the `init_transfer` operation in `tx`
 */
function get_init_transfer_details(tx: gtx_transaction, op_index: integer) {
    val op = tx.body.operations[op_index]; 

    require(
        op.name == rell.meta(init_transfer).mount_name,
        "INIT TRANSFER NOT FOUND: Invalid parameters. Expected <%s> at index <%d>, found <%s>".format(rell.meta(init_transfer).mount_name, op_index, op.name)
    );

    val tx_rid = tx.body.hash();
    val args = struct<init_transfer>.from_gtv(op.args.to_gtv());

    val auth_op = tx.body.operations[op_index - 1];
    val sender_account_id = auth.extract_account_id(auth_op);

    return (
        tx_rid = tx_rid,
        args = args,
        sender_account_id = sender_account_id
    );
}

/**
 * Given a transaction that contains the `apply_transfer` operation and the index it's at, this
 * function retrieves the transaction RID, the arguments to the `init_transfer` operation and
 * the details of the `init_transfer` as returned by `get_init_transfer_details`.
 * 
 * Throws `"APPLY TRANSFER NOT FOUND"` if the `op_index` does not point to `apply_transfer`
 * 
 * Throws if the `init_tx_op_index` of the `apply_transfer` operation does not point to
 * `init_transfer` on its `init_transfer_tx`
 * 
 * Throws if the operation preceding the `init_transfer` is not an auth operation
 * 
 * @see get_init_transfer_details for information on what details it returns
 * 
 * @see core.auth.is_auth_op for information on auth operations
 * 
 * @param tx                the transaction containing the `apply_transfer` operation
 * @param apply_op_index    the index of the `apply_transfer` operation in `tx`
 */
function get_apply_transfer_details(tx: gtx_transaction, apply_op_index: integer) {
    val op = tx.body.operations[apply_op_index];

    require(
        op.name == rell.meta(apply_transfer).mount_name,
        "APPLY TRANSFER NOT FOUND: Invalid parameters. Expected <%s> at index <%d>, found <%s>".format(rell.meta(apply_transfer).mount_name, apply_op_index, op.name)
    );

    val tx_rid = tx.body.hash();
    val args = struct<apply_transfer>.from_gtv(op.args.to_gtv());

    val init_details = get_init_transfer_details(args.init_transfer_tx, args.init_tx_op_index);

    return (
        tx_rid = tx_rid,
        args = args,
        init = init_details
    );
}
