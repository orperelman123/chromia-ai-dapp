module;

// NOTE: Non-camel case is necessary to decode properly
struct confirmation_proof {
    hash: byte_array;
    blockHeader: byte_array;
    witness: byte_array;
    merkleProofTree: list<gtv>;
    txIndex: integer;
}

struct block_header {
    blockchain_rid: byte_array;
    previous_block_rid: byte_array;
    merkle_root_hash: byte_array;
    timestamp: integer;
    height: integer;
    dependencies: gtv; // Can be either GtvNull or GtvArray
    extra: map<text,gtv>;
}

/**
 * Inter-Chain Confirmation Facility (ICCF)
 *
 * This module intends to make it easier for developers to verify that a proof has been
 * sent as a separate operation in this transaction.
 */

val iccf_op_name = "iccf_proof";
// For verifications across clusters all 6 arguments must be included in the proof
val iccf_anchored_proof_argument_count = 6;

/**
 * Requires the presented transaction to be proved and extracts an argument from the specified operation
 *
 * @param gtx_transaction The transaction to verify
 * @param op_name Name of the operation to extract
 * @param arg Index of the argument to be extracted (default: first argument)
 * @param verify_signers Whether or not the signers must match current transaction signatures
 * @param require_anchored_proof Whether or not we require inclusion of a proof that the block containing the transaction has been anchored in cluster anchoring chain
 * @param min_timestamp Limit for how old the transaction is allowed to be, disabled if 0
 * @param max_timestamp Limit for how new the transaction is allowed to be, disabled if 0
 * @param valid_source_blockchain_rids Valid source blockchains for transaction
 */
function extract_operation_arg(
    gtx_transaction,
    op_name: text,
    arg: integer = 0,
    verify_signers: boolean = true,
    require_anchored_proof: boolean = false,
    min_timestamp: integer = 0,
    max_timestamp: integer = 0,
    valid_source_blockchain_rids: set<byte_array>? = null
): gtv {
    val args = extract_operation_args(gtx_transaction, op_name, verify_signers, require_anchored_proof, min_timestamp, max_timestamp, valid_source_blockchain_rids);
    require(
        args.size() > arg,
        "Argument number %d not found on operation %s. %d arguments found"
            .format(arg, op_name, args.size())
    );
    return args[arg];
}

/**
 * Requires the presented transaction to be proved and extracts arguments of the specified operation
 *
 * @param gtx_transaction The transaction to verify
 * @param op_name Name of the operation to extract
 * @param verify_signers Whether or not the signers must match current transaction signatures
 * @param require_anchored_proof Whether or not we require inclusion of a proof that the block containing the transaction has been anchored in cluster anchoring chain
 * @param min_timestamp Limit for how old the transaction is allowed to be, disabled if 0
 * @param max_timestamp Limit for how new the transaction is allowed to be, disabled if 0
 * @param valid_source_blockchain_rids Valid source blockchains for transaction
 */
function extract_operation_args(
    gtx_transaction,
    op_name: text,
    verify_signers: boolean = true,
    require_anchored_proof: boolean = false,
    min_timestamp: integer = 0,
    max_timestamp: integer = 0,
    valid_source_blockchain_rids: set<byte_array>? = null
): list<gtv> {
    return require_operation(gtx_transaction, op_name, verify_signers, require_anchored_proof, min_timestamp, max_timestamp, valid_source_blockchain_rids).args;
}

/**
 * Requires the presented transaction to be proved and extracts the specified operation
 *
 * @param gtx_transaction The transaction to verify
 * @param op_name Name of the operation to extract
 * @param verify_signers Whether or not the signers must match current transaction signatures
 * @param require_anchored_proof Whether or not we require inclusion of a proof that the block containing the transaction has been anchored in cluster anchoring chain
 * @param min_timestamp Limit for how old the transaction is allowed to be, disabled if 0
 * @param max_timestamp Limit for how new the transaction is allowed to be, disabled if 0
 * @param valid_source_blockchain_rids Valid source blockchains for transaction
 */
function require_operation(
    gtx_transaction,
    op_name: text,
    verify_signers: boolean = true,
    require_anchored_proof: boolean = false,
    min_timestamp: integer = 0,
    max_timestamp: integer = 0,
    valid_source_blockchain_rids: set<byte_array>? = null
): gtx_operation {
    require_valid_proof(gtx_transaction, verify_signers, require_anchored_proof, min_timestamp, max_timestamp, valid_source_blockchain_rids);
    return require(
        gtx_transaction.body.operations @? { .name == op_name },
        "Operation with name %s not found in transaction %s".format(op_name, gtx_transaction)
    );
}

/**
 * Requires the presented transaction to be proved
 *
 * @param gtx_transaction The transaction to verify
 * @param verify_signers Whether or not the signers must match current transaction signatures
 * @param require_anchored_proof Whether or not we require inclusion of a proof that the block containing the transaction has been anchored in cluster anchoring chain
 * @param min_timestamp Limit for how old the transaction is allowed to be, disabled if 0
 * @param max_timestamp Limit for how new the transaction is allowed to be, disabled if 0
 * @param valid_source_blockchain_rids Valid source blockchains for transaction
 *
 * @return operations in the transaction to verify
 */
function require_valid_proof(
    gtx_transaction,
    verify_signers: boolean = true,
    require_anchored_proof: boolean = false,
    min_timestamp: integer = 0,
    max_timestamp: integer = 0,
    valid_source_blockchain_rids: set<byte_array>? = null,
): list<gtx_operation> {
    require_and_return_valid_proof(gtx_transaction, verify_signers, require_anchored_proof, min_timestamp, max_timestamp, valid_source_blockchain_rids);
    return gtx_transaction.body.operations;
}

/**
 * Requires the presented transaction to be proved
 *
 * @param gtx_transaction The transaction to verify
 * @param verify_signers Whether or not the signers must match current transaction signatures
 * @param require_anchored_proof Whether or not we require inclusion of a proof that the block containing the transaction has been anchored in cluster anchoring chain
 * @param min_timestamp Limit for how old the transaction is allowed to be, disabled if 0
 * @param max_timestamp Limit for how new the transaction is allowed to be, disabled if 0
 * @param valid_source_blockchain_rids Valid source blockchains for transaction
 *
 * @return the confirmation proof
 */
function require_and_return_valid_proof(
    gtx_transaction,
    verify_signers: boolean = true,
    require_anchored_proof: boolean = false,
    min_timestamp: integer = 0,
    max_timestamp: integer = 0,
    valid_source_blockchain_rids: set<byte_array>? = null,
): confirmation_proof =
    require_and_return_valid_proof_from_operations_and_signers(
        op_context.get_all_operations(),
        op_context.get_signers(),
        gtx_transaction,
        verify_signers,
        require_anchored_proof,
        min_timestamp,
        max_timestamp,
        valid_source_blockchain_rids);

/**
 * Requires the presented transaction to be proved
 *
 * @param all_operations All operations in the current transaction
 * @param signers Signers of the current transaction
 * @param gtx_transaction The transaction to verify
 * @param verify_signers Whether or not the signers must match current transaction signatures
 * @param require_anchored_proof Whether or not we require inclusion of a proof that the block containing the transaction has been anchored in cluster anchoring chain
 * @param min_timestamp Limit for how old the transaction is allowed to be, disabled if 0
 * @param max_timestamp Limit for how new the transaction is allowed to be, disabled if 0
 * @param valid_source_blockchain_rids Valid source blockchains for transaction
 *
 * @return the confirmation proof
 */
function require_and_return_valid_proof_from_operations_and_signers(
    all_operations: list<gtx_operation>,
    signers: list<pubkey>,
    gtx_transaction,
    verify_signers: boolean = true,
    require_anchored_proof: boolean = false,
    min_timestamp: integer = 0,
    max_timestamp: integer = 0,
    valid_source_blockchain_rids: set<byte_array>? = null,
): confirmation_proof {
    val proof = _get_proof_from_operations(all_operations, gtx_transaction, require_anchored_proof);
    require(proof, "No proof operation present for TX");

    require(
        valid_source_blockchain_rids == null or valid_source_blockchain_rids.contains(gtx_transaction.body.blockchain_rid),
        "%s is not a valid source blockchain".format(gtx_transaction.body.blockchain_rid)
    );

    if (min_timestamp != 0 or max_timestamp != 0) {
        val tx_confirmation_time = proof.block_header.timestamp;
        require(min_timestamp == 0 or tx_confirmation_time >= min_timestamp,
            "Transaction is too old, confirmed at %d in block %d".format(tx_confirmation_time, proof.block_header.height));
        require(max_timestamp == 0 or tx_confirmation_time <= max_timestamp,
            "Transaction is too new, confirmed at %d in block %d".format(tx_confirmation_time, proof.block_header.height));
    }

    if (verify_signers) {
        require(
            _has_signers_from_signers(signers, gtx_transaction),
            "Proof TX has to be signed by all the signers that signed the source TX"
        );
    }

    return proof.confirmation_proof;
}

/**
 * Checks whether or not the current transaction is signed by the same signers as the given transaction
 *
 * @param gtx_transaction The transaction to verify signers against
 */
function _has_signers(gtx_transaction): boolean = _has_signers_from_signers(op_context.get_signers(), gtx_transaction);

/**
 * Checks whether or not the current transaction is signed by the same signers as the given transaction
 *
 * @param signers  Signers of the current transaction
 * @param gtx_transaction The transaction to verify signers against
 */
function _has_signers_from_signers(signers: list<pubkey>, gtx_transaction): boolean {
    val proof_signers = gtx_transaction.body.signers @* { } ( byte_array.from_gtv($) );
    return signers.contains_all(proof_signers);
}

/**
 * Returns the `confirmation_proof` corresponding to the given transaction if there is any present in current transaction.
 * It also returns transaction hash and a decoded version of the block header in the proof.
 *
 * @param gtx_transaction The transaction to check
 * @param require_anchored_proof Whether or not we require inclusion of a proof that the block containing the transaction has been anchored in cluster anchoring chain
 */
function _get_proof(
    gtx_transaction,
    require_anchored_proof: boolean = false
): (tx_hash: byte_array, confirmation_proof: confirmation_proof, block_header: block_header)? =
    _get_proof_from_operations(op_context.get_all_operations(), gtx_transaction, require_anchored_proof);

/**
 * Returns the `confirmation_proof` corresponding to the given transaction if there is any present in current transaction.
 * It also returns transaction hash and a decoded version of the block header in the proof.
 *
 * @param all_operations All operations in the current transaction
 * @param gtx_transaction The transaction to check
 * @param require_anchored_proof Whether or not we require inclusion of a proof that the block containing the transaction has been anchored in cluster anchoring chain
 */
function _get_proof_from_operations(
    all_operations: list<gtx_operation>,
    gtx_transaction,
    require_anchored_proof: boolean = false
): (tx_hash: byte_array, confirmation_proof: confirmation_proof, block_header: block_header)? {
    val blockchain_rid = gtx_transaction.body.blockchain_rid;
    val confirmation_proofs = all_operations @* {
        .name == iccf_op_name,
        byte_array.from_gtv(.args[0]) == blockchain_rid,
        not require_anchored_proof or .args.size() == iccf_anchored_proof_argument_count
    } (
        tx_hash = byte_array.from_gtv(.args[1]),
        confirmation_proof = confirmation_proof.from_gtv_pretty(gtv.from_bytes(byte_array.from_gtv(.args[2]))),
    );
    val proofs_and_headers = confirmation_proofs @* {} (
        tx_hash = .tx_hash,
        confirmation_proof = .confirmation_proof,
        block_header = block_header.from_gtv(gtv.from_bytes(.confirmation_proof.blockHeader))
    );
    return proofs_and_headers @? { .tx_hash == gtv.legacy_hash(gtx_transaction.to_gtv(), _get_hash_version(.block_header)) };
}

function _get_hash_version(block_header) = integer.from_gtv(
    block_header.extra.get_or_default("merkle_hash_version", (1).to_gtv())
);

/**
 * Prevents this transaction to be proved multiple times by storing the hash
 *
 * @param gtx_transaction The transaction to make unique
 */
function make_transaction_unique(gtx_transaction) {
    val proof = _get_proof(gtx_transaction);
    require(proof, "Unable to find proof for TX. Please verify proof before calling 'make_transaction_unique'");
    require(
        not(exists(
            iccf_verified_transaction @? {
                .hash == proof.tx_hash,
            }
        )),
        "Transaction has already been processed"
    );
    create iccf_verified_transaction ( proof.tx_hash );
}

@log
entity iccf_verified_transaction {
    key hash: byte_array;
}
